{
  "Comment": "A description of my state machine",
  "StartAt": "Save inputs",
  "States": {
    "Save inputs": {
      "Type": "Pass",
      "Next": "Check payload valid",
      "Assign": {
        "detail": "{% $states.input %}",
        "librariesList": "{% $states.input.libraries %}",
        "payload": "{% (\n  $states.input.payload ? \n  $states.input.payload : {\n    \"version\": \"${__default_payload_version__}\"\n  }\n) %}",
        "data": "{% $states.input.payload.data ? $states.input.payload.data : {} %}",
        "engineParameters": "{% $states.input.payload.data.engineParameters ? $states.input.payload.data.engineParameters : {} %}",
        "tags": "{% $states.input.payload.data.tags ? $states.input.payload.data.tags : {} %}",
        "inputs": "{% $states.input.payload.data.inputs ? $states.input.payload.data.inputs : {} %}"
      }
    },
    "Check payload valid": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Output": "{% $states.result.Payload %}",
      "Arguments": {
        "FunctionName": "${__validate_draft_data_complete_schema_lambda_function_arn__}",
        "Payload": "{% $data %}"
      },
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 1,
          "MaxAttempts": 3,
          "BackoffRate": 2,
          "JitterStrategy": "FULL"
        }
      ],
      "Next": "Is payload complete"
    },
    "Is payload complete": {
      "Type": "Choice",
      "Choices": [
        {
          "Next": "Nothing to do",
          "Condition": "{% $states.input.isValid %}"
        }
      ],
      "Default": "Get engine parameters"
    },
    "Nothing to do": {
      "Type": "Pass",
      "End": true
    },
    "Get engine parameters": {
      "Type": "Parallel",
      "Next": "Get fastq inputs",
      "Branches": [
        {
          "StartAt": "Has Project ID",
          "States": {
            "Has Project ID": {
              "Type": "Choice",
              "Choices": [
                {
                  "Next": "Use provided project id",
                  "Condition": "{% $engineParameters.projectId ? true : false %}",
                  "Comment": "Project ID Provided"
                }
              ],
              "Default": "Get Default Project Id"
            },
            "Use provided project id": {
              "Type": "Pass",
              "End": true,
              "Output": {
                "projectId": "{% $engineParameters.projectId %}"
              }
            },
            "Get Default Project Id": {
              "Type": "Task",
              "Arguments": {
                "Name": "${__default_project_id_ssm_parameter_name__}"
              },
              "Resource": "arn:aws:states:::aws-sdk:ssm:getParameter",
              "End": true,
              "Output": {
                "projectId": "{% $states.result.Parameter.Value %}"
              }
            }
          }
        },
        {
          "StartAt": "Has Pipeline ID",
          "States": {
            "Has Pipeline ID": {
              "Type": "Choice",
              "Choices": [
                {
                  "Next": "Use provided pipeline id",
                  "Condition": "{% ($engineParameters.pipelineId ? $engineParameters.pipelineId : $detail.workflow.executionEnginePipelineId ) ? true : false %}",
                  "Comment": "Pipeline ID Provided"
                }
              ],
              "Default": "Get default pipeline id"
            },
            "Use provided pipeline id": {
              "Type": "Pass",
              "End": true,
              "Output": {
                "pipelineId": "{% $engineParameters.pipelineId ? $engineParameters.pipelineId : $detail.workflow.executionEnginePipelineId %}"
              }
            },
            "Get default pipeline id": {
              "Type": "Task",
              "Arguments": {
                "Name": "{% '${__workflow_id_to_pipeline_id_ssm_parameter_path_prefix__}/' & $detail.workflow.version %}"
              },
              "Resource": "arn:aws:states:::aws-sdk:ssm:getParameter",
              "End": true,
              "Output": {
                "pipelineId": "{% $states.result.Parameter.Value %}"
              }
            }
          }
        },
        {
          "StartAt": "Has Output URI",
          "States": {
            "Has Output URI": {
              "Type": "Choice",
              "Choices": [
                {
                  "Next": "Use provided output uri",
                  "Condition": "{% $engineParameters.outputUri ? true : false %}",
                  "Comment": "Output URI Provided"
                }
              ],
              "Default": "Get default output uri prefix"
            },
            "Use provided output uri": {
              "Type": "Pass",
              "End": true,
              "Output": {
                "outputUri": "{% $engineParameters.outputUri %}"
              }
            },
            "Get default output uri prefix": {
              "Type": "Task",
              "Arguments": {
                "Name": "${__workflow_outputs_prefix_ssm_parameter_name__}"
              },
              "Resource": "arn:aws:states:::aws-sdk:ssm:getParameter",
              "End": true,
              "Output": {
                "outputUri": "{% $states.result.Parameter.Value & $detail.portalRunId & '/' %}"
              }
            }
          }
        },
        {
          "StartAt": "Has Logs URI",
          "States": {
            "Has Logs URI": {
              "Type": "Choice",
              "Choices": [
                {
                  "Next": "Use provided logs uri",
                  "Condition": "{% $engineParameters.logsUri ? true : false %}",
                  "Comment": "Logs URI Provided"
                }
              ],
              "Default": "Get default logs uri prefix"
            },
            "Use provided logs uri": {
              "Type": "Pass",
              "End": true,
              "Output": {
                "logsUri": "{% $engineParameters.logsUri %}"
              }
            },
            "Get default logs uri prefix": {
              "Type": "Task",
              "Arguments": {
                "Name": "${__workflow_logs_prefix_ssm_parameter_name__}"
              },
              "Resource": "arn:aws:states:::aws-sdk:ssm:getParameter",
              "End": true,
              "Output": {
                "logsUri": "{% $states.result.Parameter.Value & $detail.portalRunId & '/' %}"
              }
            }
          }
        },
        {
          "StartAt": "Has Cache URI",
          "States": {
            "Has Cache URI": {
              "Type": "Choice",
              "Choices": [
                {
                  "Next": "Use provided cache uri",
                  "Condition": "{% $engineParameters.cacheUri ? true : false %}",
                  "Comment": "Cache URI Provided"
                }
              ],
              "Default": "Get default cache uri prefix"
            },
            "Use provided cache uri": {
              "Type": "Pass",
              "End": true,
              "Output": {
                "cacheUri": "{% $engineParameters.cacheUri %}"
              }
            },
            "Get default cache uri prefix": {
              "Type": "Task",
              "Arguments": {
                "Name": "${__workflow_cache_prefix_ssm_parameter_name__}"
              },
              "Resource": "arn:aws:states:::aws-sdk:ssm:getParameter",
              "End": true,
              "Output": {
                "cacheUri": "{% $states.result.Parameter.Value & $detail.portalRunId & '/' %}"
              }
            }
          }
        }
      ],
      "Assign": {
        "engineParameters": "{% /* https://try.jsonata.org/6nUH8BUBr */\n [ $engineParameters, $merge($states.result) ] ~> $merge  %}"
      }
    },
    "Get fastq inputs": {
      "Type": "Parallel",
      "Next": "Generate BCLConvert InterOp QC Draft Data Event",
      "Branches": [
        {
          "StartAt": "Get Fastq IDs in Instrument Run ID",
          "States": {
            "Get Fastq IDs in Instrument Run ID": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Output": {
                "fastqIdList": "{% $states.result.Payload.fastqIdList %}"
              },
              "Arguments": {
                "FunctionName": "${__get_fastq_ids_in_instrument_run_id_lambda_function_arn__}",
                "Payload": {
                  "instrumentRunId": "{% $inputs.instrumentRunId ? $inputs.instrumentRunId : $tags.instrumentRunId %}"
                }
              },
              "Retry": [
                {
                  "ErrorEquals": [
                    "Lambda.ServiceException",
                    "Lambda.AWSLambdaException",
                    "Lambda.SdkClientException",
                    "Lambda.TooManyRequestsException"
                  ],
                  "IntervalSeconds": 1,
                  "MaxAttempts": 3,
                  "BackoffRate": 2,
                  "JitterStrategy": "FULL"
                }
              ],
              "Next": "Iterate over each fastq id (batched)"
            },
            "Iterate over each fastq id (batched)": {
              "Type": "Map",
              "ItemProcessor": {
                "ProcessorConfig": {
                  "Mode": "DISTRIBUTED",
                  "ExecutionType": "STANDARD"
                },
                "StartAt": "Set local vars",
                "States": {
                  "Set local vars": {
                    "Type": "Pass",
                    "Next": "Jitter",
                    "Assign": {
                      "fastqIdListMapIter": "{% $states.input.Items %}"
                    }
                  },
                  "Jitter": {
                    "Type": "Wait",
                    "Seconds": "{% $round($random() * $states.input.BatchInput.itemCount) + 1 %}",
                    "Next": "Fastq Sync (wait for qc to complete)"
                  },
                  "Fastq Sync (wait for qc to complete)": {
                    "Type": "Task",
                    "Resource": "arn:aws:states:::events:putEvents.waitForTaskToken",
                    "Arguments": {
                      "Entries": [
                        {
                          "Detail": {
                            "taskToken": "{% $states.context.Task.Token %}",
                            "payload": {
                              "fastqIdList": "{% $fastqIdListMapIter %}",
                              "requirements": {
                                "hasQc": true
                              },
                              "forceUnarchiving": false
                            }
                          },
                          "DetailType": "${__fastq_sync_detail_type__}",
                          "EventBusName": "${__event_bus_name__}",
                          "Source": "${__stack_source__}"
                        }
                      ]
                    },
                    "Next": "Get multiqc parquet outputs"
                  },
                  "Get multiqc parquet outputs": {
                    "Type": "Task",
                    "Resource": "arn:aws:states:::lambda:invoke",
                    "Arguments": {
                      "FunctionName": "${__get_multiqc_parquet_outputs_from_fastq_id_list_lambda_function_arn__}",
                      "Payload": {
                        "fastqIdList": "{% $fastqIdListMapIter %}"
                      }
                    },
                    "Retry": [
                      {
                        "ErrorEquals": [
                          "Lambda.ServiceException",
                          "Lambda.AWSLambdaException",
                          "Lambda.SdkClientException",
                          "Lambda.TooManyRequestsException"
                        ],
                        "IntervalSeconds": 1,
                        "MaxAttempts": 3,
                        "BackoffRate": 2,
                        "JitterStrategy": "FULL"
                      }
                    ],
                    "End": true,
                    "Output": {
                      "multiqcOutputObject": "{% $states.result.Payload.multiqcOutputObject %}"
                    }
                  }
                }
              },
              "Label": "Iterateovereachfastqidbatched",
              "MaxConcurrency": 1000,
              "ItemBatcher": {
                "MaxItemsPerBatch": 10,
                "BatchInput": {
                  "itemCount": "{% $count($states.input.fastqIdList) %}"
                }
              },
              "Items": "{% $states.input.fastqIdList %}",
              "Output": {
                "additionalMultiQcDataFiles": "{% [ $states.result.(multiqcOutputObject) ] %}"
              },
              "Next": "Get BSSH Fastq Copy output"
            },
            "Get BSSH Fastq Copy output": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Arguments": {
                "FunctionName": "${__get_bssh_fastq_outputs_lambda_function_arn__}",
                "Payload": {
                  "instrumentRunId": "{% $inputs.instrumentRunId ? $inputs.instrumentRunId : $tags.instrumentRunId %}",
                  "libraryIdList": "{% [ $librariesList.(libraryId) ] %}"
                }
              },
              "Retry": [
                {
                  "ErrorEquals": [
                    "Lambda.ServiceException",
                    "Lambda.AWSLambdaException",
                    "Lambda.SdkClientException",
                    "Lambda.TooManyRequestsException"
                  ],
                  "IntervalSeconds": 1,
                  "MaxAttempts": 3,
                  "BackoffRate": 2,
                  "JitterStrategy": "FULL"
                }
              ],
              "Output": {
                "interOpDirectory": "{% $states.result.Payload.interOpDirectory ? $states.result.Payload.interOpDirectory : null %}",
                "bclConvertReportDirectory": "{% $states.result.Payload.bclConvertReportDirectory ? $states.result.Payload.bclConvertReportDirectory : null %}",
                "additionalMultiQcDataFiles": "{% $states.input.additionalMultiQcDataFiles %}"
              },
              "End": true
            }
          }
        },
        {
          "StartAt": "Pass",
          "States": {
            "Pass": {
              "Type": "Pass",
              "Output": {},
              "End": true
            }
          }
        }
      ],
      "Assign": {
        "inputs": "{% [\n  /* Force the instrument run id value from the tags */\n  {\n    \"instrumentRunId\": $tags.instrumentRunId\n  },\n  /* Then add in the draft inputs */\n  $inputs,\n  /* Add in the merged results */\n  (\n    $states.result ~> $merge\n  )\n] ~> \n/* Merge this all together */\n$merge %}"
      }
    },
    "Generate BCLConvert InterOp QC Draft Data Event": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Arguments": {
        "FunctionName": "${__generate_bclconvert_interopqc_draft_data_event_lambda_function_arn__}",
        "Payload": {
          "portalRunId": "{% $detail.portalRunId %}",
          "inputs": "{% $inputs %}",
          "tags": "{% $tags %}",
          "engineParameters": "{% $engineParameters %}"
        }
      },
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 1,
          "MaxAttempts": 3,
          "BackoffRate": 2,
          "JitterStrategy": "FULL"
        }
      ],
      "Next": "Push BCLConvert InterOp QC Draft Event",
      "Output": {
        "eventDetail": "{% $states.result.Payload.eventDetail %}"
      }
    },
    "Push BCLConvert InterOp QC Draft Event": {
      "Type": "Task",
      "Resource": "arn:aws:states:::events:putEvents",
      "Arguments": {
        "Entries": [
          {
            "Detail": "{% $states.input.eventDetail %}",
            "DetailType": "${__workflow_run_update_event_detail_type__}",
            "EventBusName": "${__event_bus_name__}",
            "Source": "${__stack_source__}"
          }
        ]
      },
      "End": true
    }
  },
  "QueryLanguage": "JSONata"
}
